import os
from fsanitize.logmgr import logger


def recursive_rename(direc):
    '''Main renaming function.

    Arguments:
    direc -- the directory to sanitize
    '''

    try:
        for x in os.scandir(direc):
            if x.is_dir():
                recursive_rename(x)
            renamer(x)
    except PermissionError as error:
        logger.error('%s', str(error))
    except Exception as error:
        message = "An exception of type {}, with args {}, message {}".format(type(error).__name__, error.args,
                                                                             str(error))
        logger.error('Unexpected: %s', message)


def renamer(x):
    '''Call os.rename on argument provided.

    Argument:
    x -- path of file or directory to rename.
    '''

    fbit = False if x.is_dir() else True

    new_name = name_maker(x.name, fbit)

    if not x.name == new_name:
        checked_name = check_duplicates(new_name, x.path, fbit)

        old_path = x.path
        new_path = os.path.join(os.path.dirname(x), checked_name)

        os.rename(old_path, new_path)
        logger.info('renamed file %s to %s', old_path, new_path)


def name_maker(fname, fbit=False):
    """Creates new name for files using str.maketrans

    Arguments:
    fname -- filename to sanitize

    Keyword Arguments:
    fbit -- boolean, set true to save the last . and preserve file extensions (default False)
    """

    upper_letters = 'QAZWSXEDCRFVTGBYHNUJMIKOLP'
    lower_letters = 'qazwsxedcrfvtgbyhnujmikolp'

    if not fbit:
        # make a string translation table for directory names

        symbols = '~!@#$%^&*()_+=-`][|}{":;?></ ,.'
        underscores = '_' * len(symbols)

        original_string = upper_letters + symbols
        translation_string = lower_letters + underscores

        # create mapping and translate
        table = str.maketrans(original_string, translation_string)
        newname = fname.translate(table)

    else:
        # for files, don't modify the . (dot)

        symbols = '~!@#$%^&*()_+=-`][|}{":;?></ ,'
        underscores = '_' * len(symbols)

        original_string = upper_letters + symbols
        translation_string = lower_letters + underscores

        # create mapping and translate
        table = str.maketrans(original_string, translation_string)
        newname = fname.translate(table)

        corrected = False
        # iterate over the name in reverse, and skip the first .
        for index, value in enumerate(fname[::-1]):
            if value == '.':
                if corrected is False:
                    corrected = True
                else:
                    newname = newname[:(len(newname) - 1 - index)] + '_' + newname[-index:]

    # ideally, this function should not be called by name_maker
    newname = remove_multiple_underscores(newname)
    return newname


def remove_multiple_underscores(name):
    """Removes multiple consecutive underscores from the argument and return it.

    Arguments:
    name -- string to remove multiple consecutive underscores from
    """

    new_name = name[:1]

    for i in range(len(name)):
        if not i == 0:
            if name[i] == '_' and name[i - 1] == '_':
                continue
            else:
                new_name += name[i]
    return new_name


def check_duplicates(new_name, file_path, fbit=False):
    """Handles duplicate names created during rename operation

    Arguments:
    new_name -- new name generated by name_maker which is to be checked
    file_path -- original file path

    Keyword Arguments:
    fbit -- boolean, set true to save the last . and preserve file extensions (default False)
    """

    while os.path.exists(os.path.join(os.path.dirname(file_path), new_name)):
        if fbit:
            split_name = new_name.split('.')
            try:
                split_name[-2] = split_name[-2] + '_'
                new_name = '.'.join(split_name)
            except IndexError:
                new_name += '_'
        else:
            new_name += '_'

    return new_name
